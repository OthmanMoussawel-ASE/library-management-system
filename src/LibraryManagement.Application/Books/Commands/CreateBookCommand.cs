using AutoMapper;
using LibraryManagement.Application.Books.DTOs;
using LibraryManagement.Application.Common.Interfaces;
using LibraryManagement.Application.Common.Models;
using LibraryManagement.Domain.Entities;
using LibraryManagement.Domain.Interfaces;
using MediatR;

namespace LibraryManagement.Application.Books.Commands;

public record CreateBookCommand(CreateBookRequest Request) : IRequest<Result<BookDto>>;

public class CreateBookCommandHandler : IRequestHandler<CreateBookCommand, Result<BookDto>>
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly IMapper _mapper;
    private readonly IAIService _aiService;
    private readonly ICacheService _cacheService;

    public CreateBookCommandHandler(IUnitOfWork unitOfWork, IMapper mapper, IAIService aiService, ICacheService cacheService)
    {
        _unitOfWork = unitOfWork;
        _mapper = mapper;
        _aiService = aiService;
        _cacheService = cacheService;
    }

    public async Task<Result<BookDto>> Handle(CreateBookCommand command, CancellationToken cancellationToken)
    {
        var request = command.Request;

        if (!string.IsNullOrEmpty(request.ISBN))
        {
            var existing = await _unitOfWork.Books.GetByIsbnAsync(request.ISBN, cancellationToken);
            if (existing is not null)
                return Result<BookDto>.Failure("A book with this ISBN already exists.");
        }

        var author = await _unitOfWork.Repository<Author>().GetByIdAsync(request.AuthorId, cancellationToken);
        if (author is null)
            return Result<BookDto>.NotFound("Author not found.");

        var description = request.Description;
        if (request.AutoGenerateDescription && string.IsNullOrEmpty(description) && _aiService.IsAvailable)
        {
            description = await _aiService.GenerateBookDescriptionAsync(request.Title, author.FullName, cancellationToken);
        }

        var book = new Book
        {
            Title = request.Title,
            ISBN = request.ISBN,
            Description = description,
            CoverImageUrl = request.CoverImageUrl,
            TotalCopies = request.TotalCopies,
            AvailableCopies = request.TotalCopies,
            PublishedDate = request.PublishedDate,
            Publisher = request.Publisher,
            PageCount = request.PageCount,
            Language = request.Language,
            AuthorId = request.AuthorId
        };

        if (request.CategoryIds?.Count > 0)
        {
            foreach (var categoryId in request.CategoryIds)
            {
                book.BookCategories.Add(new BookCategory { BookId = book.Id, CategoryId = categoryId });
            }
        }

        await _unitOfWork.Books.AddAsync(book, cancellationToken);
        await _unitOfWork.SaveChangesAsync(cancellationToken);

        await _cacheService.RemoveByPrefixAsync("books_", cancellationToken);

        var createdBook = await _unitOfWork.Books.GetByIdWithDetailsAsync(book.Id, cancellationToken);
        return Result<BookDto>.Success(_mapper.Map<BookDto>(createdBook));
    }
}
